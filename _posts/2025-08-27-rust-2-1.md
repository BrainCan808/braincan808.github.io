---
layout: post
title: "1. 変数とデータ型"
date: 2025-08-27 22:22:00 +0900
categories: [Rust, "[2]"]
tags: [言語，Rust]
---
## １．変数、束縛、代入
### (1) 変数の宣言
- let：変数が束縛される
- mut：let変数が代入される

### (2) 束縛
- 変数の値を再度変えることが出来ない

### (3) 代入
- 変数を何度でも変えられる

### (4) シャドーイング
- letで宣言された変数を再度宣言できる
```rust
let x = "x"
let x = "xxx"
```

## ２．定数
- constで宣言
- 変更不可
- 型アノテーションが必須
- 関数の戻り値を設定不可
- 主に実装者以外に理解が難しい数字や文字列のラベリングに使う
```rust
const URL: &str = "https://google.com/"
```

## ３．データ型
### (1) 整数型
```rust
i8, i16, i32, i64, isize
u8, u16, u32, u64, usize
```
- iで始まるもの：正負を扱える
- uで始まるもの：符号なし
- 後ろの数字：bitの数を表す
- 後ろのsize：実行環境によってbitが変わる（64ビットのパソコンでは64になる）

### (2) 浮動小数点型
```rust
f32, f64
```
- 後ろの数字：整数と同様、ビットを表す
- 基本的にf64を利用（制度が高い、処理スピードがほぼ変わらない）

### (3) 論理値型
```rust
let yesno: bool = true;
```
- trueとfalesを表す

### (4) 文字型
```rust
let a: char = 'a';
```
- 'で指定
- １文字だけ表示

### (5) タプル型
```rust
let tp = ("hello", 123)
tp.0
tp.1
```
- 複数の異なる型を持つ
- インデックスを利用する（.の後番号を指定）

### (6) 配列型
```rust
let arr = ["qwer", "asdf", "zxcv"];
arr[0]
arr[1]
arr[2]
```
- サイズを変更できない（固定長）

### (7) ベクター型
```rust
let mut v: Vec<i32> = Vec::new()
v.push(99); 
let v = vec![1, 2, 3];
```
- サイズが変更できる（可変長）
- 要素をpushメソッドを使って追加
- 破壊的メソッド（vec!）：データ構造に破壊的変更をもたらすメソッド、mutを付けて可変な変数にしなければ利用できない

### (8) 文字列
1. 文字列スライス
```rust
let s: &str = "hello";
```
- 文字列を読むことだけできる
2. String型
```rust
let msg = String::from("hello, world");
let msg_string = msg.to_string();
msg_string.push_str(", world") // hello, world
```
- 文字列を追加、削除、変更可能

### (9) ハッシュマップ
```rust
let mut scores = std::collections::HashMap::new();
scores.insert("Sato", 100);
scores.insert("Tanaka", 90);
scores.entry("Tanaka").or_insert(100); //Tanakaがなっかったら100をinsert

let solar_distance = std::collections::HashMap::from([
    ("Mercury", 0.4),
    ("Venus", 0.7),
    ("Earth", 1.0),
    ("Mars", 1.5),
]);
```
- HashMap<K, V>：Kはキー、Vはバリュー
- 格、型を書きますが直後insertすると推論してくれるので書かなくてもいい